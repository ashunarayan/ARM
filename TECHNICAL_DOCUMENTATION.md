# Road Quality Monitoring System - Technical Documentation

## Project Overview
- Crowd-sourced road quality monitoring system using mobile device sensors
- Real-time data collection, on-device ML inference, backend aggregation, and live updates
- Stack: Node.js backend, TensorFlow Lite ML model, React Native mobile app

## Backend Architecture

### Why Node.js + Express
- Stateless REST API with Express for scalability
- Socket.IO integration for real-time WebSocket communication
- Asynchronous processing for map matching and aggregation
- Single-threaded event loop handles concurrent connections efficiently

### MongoDB Usage
- **users**: Stores user accounts (email, password hash, deviceId, firebaseUid, isAnonymous flag)
- **observations**: Raw road quality data points with location (GeoJSON Point), roadQuality (0-3), timestamp, roadSegmentId, regionId, speed
- **roadSegments**: Aggregated road quality per segment with geometry (GeoJSON LineString), aggregatedQualityScore, observationCount, regionId
- Geospatial 2dsphere indexes on location fields for proximity queries
- TTL index on observations (30-day auto-expiry)

### Redis Usage
- **Session management**: Active socket connections (session:{socketId}, 1h TTL)
- **Region membership**: Tracks which users are in which geohash regions (region:{regionId}:members, 1h TTL)
- **Heartbeat tracking**: Last activity timestamps (heartbeat:{socketId}, 5min TTL)
- All data auto-expires via TTL to handle disconnections gracefully
- Not required for system operation (graceful degradation if unavailable)

### Firebase Admin SDK Usage
- Server-side token verification only
- `verifyIdToken()` validates Firebase ID tokens from mobile clients
- Auto-creates User records in MongoDB on first Firebase login
- Maps Firebase UID to internal userId in User collection

### JWT vs Firebase Auth
- **Firebase Auth**: Used by mobile app for authentication (email/password via @react-native-firebase/auth)
- **JWT**: Generated by backend for anonymous device-based sessions (deviceId-based users)
- Backend accepts both: Firebase tokens verified via Admin SDK, JWTs verified via JWT_SECRET
- Firebase tokens converted to User records, then attached to req.userId for authorization

### Socket.IO Usage
- Regional rooms based on geohash (precision 6, ~1.2km × 0.61km areas)
- **Client → Server**: `join-region`, `update-location` (auto room switching)
- **Server → Client**: `road-quality-update` broadcasts when aggregated scores change
- Authentication via JWT/Firebase token in Socket.IO handshake
- Broadcasts only to users in same geohash region for efficiency

## ML Module

### What the Model Predicts
- Road surface quality classification: 4 classes (0=Good, 1=Average, 2=Bad, 3=Very Bad)

### Input Features
- **Raw sensor data**: 20-sample window (2 seconds at 10Hz) of 7 channels: [ax, ay, az, wx, wy, wz, speed]
- **Statistical features**: 42 aggregated metrics (mean, std, RMS, range, skewness, kurtosis) computed per channel
- Dual-input Hybrid CNN-MLP architecture

### Output Classes
- **0**: Good road (smooth pavement)
- **1**: Average road (minor imperfections)
- **2**: Bad road (potholes, rough surface)
- **3**: Very Bad road (unpaved, severe damage)

### How ML Pipeline Connects to Mobile App
- Model trained in Python (Keras/TensorFlow), exported as `model.tflite` and `scaler_params.json`
- TFLite model embedded in mobile app assets
- App collects sensors at 10Hz, creates 20-sample windows
- Normalizes inputs using scaler_params.json (StandardScaler mean/std from training)
- On-device inference (no network required)
- Predicted class (0-3) sent to backend with GPS location

## Mobile App (RoadApp)

### Tech Stack
- React Native 0.83.1 (TypeScript)
- @react-native-firebase/auth for authentication
- @rnmapbox/maps for map visualization
- socket.io-client for real-time updates
- TFLite inference (currently mocked due to build issues)

### Firebase Authentication Flow
1. User enters email/password in AuthScreen
2. `auth().signInWithEmailAndPassword()` authenticates with Firebase
3. `user.getIdToken()` retrieves Firebase ID token
4. Token stored in AsyncStorage and attached to all backend requests via axios interceptor
5. Backend verifies token with Firebase Admin SDK, returns or creates User in MongoDB

### Mapbox Usage
- Displays base map with user location tracking
- Visualizes road segments with color-coded quality overlays (fetched from backend)
- Uses MAPBOX_ACCESS_TOKEN for map tile rendering
- Does not perform routing/navigation (display only)

### On-Device TFLite Model Inference
- Model loaded from `src/assets/model.tflite` (currently mocked)
- MLService collects 20 sensor readings (ax, ay, az, wx, wy, wz, speed)
- Computes statistical features (mean, std, RMS, range, skewness, kurtosis)
- Normalizes using scaler_params.json
- Predicts road quality class (0-3)
- No network required for inference

### Data Sent to Backend Per Observation
- `latitude`, `longitude`: GPS coordinates
- `roadQuality`: Predicted class from ML model (0-3)
- `timestamp`: ISO 8601 datetime
- `speed`: GPS speed in km/h (optional)
- `deviceMetadata`: {model, os, appVersion}
- Sent as POST /api/observations with Firebase token in Authorization header

## End-to-End Flow

1. **User opens app** → Firebase Authentication → Receives Firebase ID token
2. **App loads TFLite model** → MLService.loadModel() loads model and scaler params
3. **User starts driving** → App collects accelerometer, gyroscope, GPS speed at 10Hz
4. **Every 2 seconds** → MLService creates 20-sample window, computes statistics, normalizes, runs inference → Predicts roadQuality (0-3)
5. **Observation created** → {latitude, longitude, roadQuality, speed, timestamp} → ObservationService.submitObservation()
6. **Backend receives observation** → POST /api/observations → Validates with Firebase token → Gets userId from MongoDB
7. **Map matching** → Backend calls OSRM API → Snaps GPS point to nearest road → Generates roadSegmentId
8. **Geohash calculation** → Computes regionId from coordinates (6-char geohash)
9. **Store in MongoDB** → Creates Observation document → Upserts RoadSegment document
10. **Aggregation** → Calculates weighted average roadQuality for segment (time decay + speed weighting) → Updates RoadSegment.aggregatedQualityScore
11. **Real-time broadcast** → If score changes significantly → Socket.IO emits `road-quality-update` to region:{regionId} room
12. **Mobile app receives update** → SocketService.onRoadQualityUpdate() → Reloads road segments from GET /api/roads/segments
13. **Map updates** → Mapbox displays color-coded road segments based on aggregatedQualityScore
